# Go parameters
GO_CMD=go
GO_BUILD=$(GO_CMD) build
GO_CLEAN=$(GO_CMD) clean
GO_TEST=$(GO_CMD) test
GO_FMT=$(GO_CMD) fmt
GO_VET=$(GO_CMD) vet
GO_RUN=$(GO_CMD) run

# Project variables
DIST_DIR=dist
BINARY_DIR=bin
MANAGER_BINARY=manager
WORKER_BINARY=worker
MANAGER_MAIN=./cmd/manager/main.go
WORKER_MAIN=./cmd/worker/main.go

.PHONY: all build manager worker run test fmt vet generate install-crds uninstall-crds clean

all: build

# Build binaries
build: manager worker

manager:
	@echo "Building manager..."
	@$(GO_BUILD) -o $(DIST_DIR)/$(MANAGER_BINARY) $(MANAGER_MAIN)

worker:
	@echo "Building worker..."
	@$(GO_BUILD) -o $(DIST_DIR)/$(WORKER_BINARY) $(WORKER_MAIN)

# Run the manager
run:
	@echo "Running manager..."
	@$(GO_RUN) $(MANAGER_MAIN)

# Run tests
test:
	@echo "Running tests..."
	@$(GO_TEST) -v ./...

# Format code
fmt:
	@echo "Formatting code..."
	@$(GO_FMT) ./...

# Vet code
vet:
	@echo "Vetting code..."
	@$(GO_VET) ./...

# Generate code
generate:
	@echo "Generating code..."
	@./$(BINARY_DIR)/generate-code.sh

# CRD management
install-crds:
	@echo "Installing CRDs..."
	@./$(BINARY_DIR)/install-crds.sh

uninstall-crds:
	@echo "Uninstalling CRDs..."
	@./$(BINARY_DIR)/uninstall-crds.sh

# Integration test variables
INTEGRATION_TEST_DIR=test/integration
INTEGRATION_TEST_TIMEOUT=30m
ENVTEST_K8S_VERSION=1.28.0
ENVTEST_BIN_DIR=$(shell pwd)/bin

# Test targets
test-unit:
	@echo "Running unit tests..."
	@$(GO_TEST) -v -race -coverprofile=coverage.out ./pkg/...

# Setup envtest binaries
setup-envtest:
	@echo "Setting up envtest binaries..."
	@mkdir -p $(ENVTEST_BIN_DIR)
	@go install sigs.k8s.io/controller-runtime/tools/setup-envtest@latest
	@setup-envtest use $(ENVTEST_K8S_VERSION) --bin-dir $(ENVTEST_BIN_DIR) -p env > /tmp/envtest.env
	@echo "Envtest binaries installed to $(ENVTEST_BIN_DIR)"

test-integration:
	@echo "Running integration tests..."
	@echo "Note: Running tests without envtest setup - tests may be skipped if no cluster available"
	@export USE_EXISTING_CLUSTER=false && \
	export KUBEBUILDER_ASSETS="" && \
	$(GO_TEST) -v -timeout $(INTEGRATION_TEST_TIMEOUT) ./$(INTEGRATION_TEST_DIR)/...

test-integration-simple:
	@echo "Running integration tests without envtest setup..."
	@echo "Note: This may fail if envtest binaries are not available"
	@export USE_EXISTING_CLUSTER=false && \
	export KUBEBUILDER_ASSETS="" && \
	$(GO_TEST) -v -timeout $(INTEGRATION_TEST_TIMEOUT) ./$(INTEGRATION_TEST_DIR)/...

test-integration-setup:
	@echo "Setting up integration test environment..."
	@./$(INTEGRATION_TEST_DIR)/setup.sh

test-integration-with-setup: test-integration-setup
	@echo "Running integration tests with setup..."
	@$(GO_TEST) -v -timeout $(INTEGRATION_TEST_TIMEOUT) ./$(INTEGRATION_TEST_DIR)/...

test-integration-kind:
	@echo "Running integration tests with Kind..."
	@USE_KIND=true ./$(INTEGRATION_TEST_DIR)/setup.sh
	@$(GO_TEST) -v -timeout $(INTEGRATION_TEST_TIMEOUT) ./$(INTEGRATION_TEST_DIR)/...

test-integration-cleanup:
	@echo "Cleaning up integration test environment..."
	@kind delete cluster --name shard-controller-test || true

test-performance:
	@echo "Running performance tests..."
	@$(GO_TEST) -v -timeout $(INTEGRATION_TEST_TIMEOUT) -run "Performance" ./$(INTEGRATION_TEST_DIR)/...

test-load-balancing:
	@echo "Running load balancing integration tests..."
	@$(GO_TEST) -v -timeout $(INTEGRATION_TEST_TIMEOUT) -run "LoadBalancing" ./$(INTEGRATION_TEST_DIR)/...

test-all: test-unit test-integration

# Coverage report
coverage:
	@echo "Generating coverage report..."
	@$(GO_TEST) -v -race -coverprofile=coverage.out ./pkg/...
	@$(GO_CMD) tool cover -html=coverage.out -o coverage.html
	@echo "Coverage report generated: coverage.html"

# Docker variables
REGISTRY ?= shard-controller
TAG ?= latest
VERSION ?= $(shell git describe --tags --always --dirty)
COMMIT ?= $(shell git rev-parse HEAD)
BUILD_DATE ?= $(shell date -u +'%Y-%m-%dT%H:%M:%SZ')

# Docker build targets
.PHONY: docker-build docker-build-manager docker-build-worker docker-push docker-push-manager docker-push-worker

# Build all Docker images
docker-build: docker-build-manager docker-build-worker

# Build manager Docker image
docker-build-manager:
	@echo "Building manager Docker image..."
	@docker build \
		--build-arg VERSION=$(VERSION) \
		--build-arg COMMIT=$(COMMIT) \
		--build-arg BUILD_DATE=$(BUILD_DATE) \
		-f Dockerfile.manager \
		-t $(REGISTRY)/manager:$(TAG) \
		-t $(REGISTRY)/manager:$(VERSION) \
		.

# Build worker Docker image
docker-build-worker:
	@echo "Building worker Docker image..."
	@docker build \
		--build-arg VERSION=$(VERSION) \
		--build-arg COMMIT=$(COMMIT) \
		--build-arg BUILD_DATE=$(BUILD_DATE) \
		-f Dockerfile.worker \
		-t $(REGISTRY)/worker:$(TAG) \
		-t $(REGISTRY)/worker:$(VERSION) \
		.

# Build using multi-stage Dockerfile
docker-build-multi:
	@echo "Building manager image using multi-stage Dockerfile..."
	@docker build \
		--build-arg COMPONENT=manager \
		--build-arg VERSION=$(VERSION) \
		--build-arg COMMIT=$(COMMIT) \
		--build-arg BUILD_DATE=$(BUILD_DATE) \
		-t $(REGISTRY)/manager:$(TAG) \
		.
	@echo "Building worker image using multi-stage Dockerfile..."
	@docker build \
		--build-arg COMPONENT=worker \
		--build-arg VERSION=$(VERSION) \
		--build-arg COMMIT=$(COMMIT) \
		--build-arg BUILD_DATE=$(BUILD_DATE) \
		-t $(REGISTRY)/worker:$(TAG) \
		.

# Push all Docker images
docker-push: docker-push-manager docker-push-worker

# Push manager Docker image
docker-push-manager:
	@echo "Pushing manager Docker image..."
	@docker push $(REGISTRY)/manager:$(TAG)
	@docker push $(REGISTRY)/manager:$(VERSION)

# Push worker Docker image
docker-push-worker:
	@echo "Pushing worker Docker image..."
	@docker push $(REGISTRY)/worker:$(TAG)
	@docker push $(REGISTRY)/worker:$(VERSION)

# Build and push all images
docker-release: docker-build docker-push

# Load images into kind cluster
kind-load:
	@echo "Loading images into kind cluster..."
	@kind load docker-image $(REGISTRY)/manager:$(TAG) --name shard-controller-demo || true
	@kind load docker-image $(REGISTRY)/worker:$(TAG) --name shard-controller-demo || true

# Clean build artifacts
clean:
	@echo "Cleaning up..."
	@if [ -f $(BINARY_DIR)/$(MANAGER_BINARY) ]; then rm $(BINARY_DIR)/$(MANAGER_BINARY); fi
	@if [ -f $(BINARY_DIR)/$(WORKER_BINARY) ]; then rm $(BINARY_DIR)/$(WORKER_BINARY); fi
	@if [ -f coverage.out ]; then rm coverage.out; fi
	@if [ -f coverage.html ]; then rm coverage.html; fi

# Clean Docker images
docker-clean:
	@echo "Cleaning Docker images..."
	@docker rmi $(REGISTRY)/manager:$(TAG) $(REGISTRY)/manager:$(VERSION) || true
	@docker rmi $(REGISTRY)/worker:$(TAG) $(REGISTRY)/worker:$(VERSION) || true

